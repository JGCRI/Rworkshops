---
title: "Data visualization using ggplot2 (intermediate)"
author: "BBL"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    code_folding: hide
---

The introductory workshop material is here: [Part 1](https://rpubs.com/bpbond/727254), [Part 2](https://rpubs.com/bpbond/727256).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(emo)  # install via devtools::install_github("hadley/emo")
library(ggplot2)
thm <- theme_minimal()
theme_set(thm)
drk <- theme(panel.background = element_rect(fill = "gray"))
```

TODO

* section on positioning
* 3D - end of geoms section


# Topics

* The ggplot2 pipeline
* Plot layers
* The relationship between stats and geoms
* Scales
* Coordinate transformations
* Expressions
* Annotations

**Goal: .**


# Assumptions

<span style="color: red;">**We assume you're familiar with the basic mechanics of ggplot2**</span> as covered in the introductory workshop:

* Data visualization concepts
* Grammar of graphics
* Building a plot: dataset structure, `ggplot()`, aesthetics, geoms, labels, themes, facets
* Aesthetic and theme inheritance principles


# The ggplot2 pipeline

[Figure 13.2 from the ggplot2 book](https://ggplot2-book.org/mastery.html#fig:schematic)

![](https://ggplot2-book.org/diagrams/mastery-schema.png)


# Plot layers

We think of geoms as layers, and that's usually true, what actually makes up a _plot layer_?

* An optional **mapping** of aesthetics that supplements or overrides the default mapping set in `ggplot()`
* An optional **dataset** that overrides the default plot dataset
* A **geom**: the geometric object used to draw each observation
* A **stat**: the statistical transformation to use (even if it's only the “identity” stat)
* A **position** used to adjust overlapping objects

With this we can start to truly understand the [usage of `geom_point()`](https://ggplot2.tidyverse.org/reference/geom_point.html) for example:
```
geom_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
```

# Geoms

## Fundamentals

Let's talk about **geoms**---geometric objects. They are the fundamental building blocks of ggplot2, and can be put into several categories. There are the basic geoms:

Geom             | Requires | Understands                    | Notes
---------------- | -------- | ------------------------------ | -------
`geom_point()`   | `x`, `y` | `color`, `size`, ...           | cf. `geom_jitter()`
`geom_line()`    | `x`, `y` | `color`, `size`, `linetype`... | cf. `geom_path()`
`geom_bar()`     | `x`, `y` | `color`, `fill`, ...           | cf. `geom_col()`
`geom_area()`    | `x` **or** `y` (also min, max) | `color`, `fill`          | cf. `geom_ribbon()`
Polygon geoms    | `x`, `y` | `color`, `size`, `linetype`... | `geom_rect()`, `geom_tile()`, `geom_polygon()`

```{r basic-geoms, message=FALSE, fig.show="hold", out.width="33%"}
theme_update(title = element_text(size = 20, face = "bold"))
df <- data.frame(x = c(3, 1, 5), 
                 y = c(2, 4, 6))
base <- ggplot(df, aes(x, y)) +
  labs(x = NULL, y = NULL)

base + geom_point() + ggtitle("point")
base + geom_jitter() + ggtitle("jitter")
base + geom_line() + ggtitle("line")
base + geom_path() + ggtitle("path")
base + geom_bar(stat = "identity") + ggtitle("bar")
base + geom_tile() + ggtitle("tile")
base + geom_raster() + ggtitle("raster")
base + geom_polygon() + ggtitle("polygon")
base + geom_area() + ggtitle("area")
```

I would also call these basic, but they have additional aesthetic requirements: `xmin`, `xmax`, `ymin`, and `ymax`:

```{r minmax-geoms, message=FALSE, fig.show="hold", out.width="50%"}
df <- data.frame(x = c(3, 1, 5), 
                 xmin = c(2, 0, 2),
                 xmax = c(4, 3, 5),
                 y = c(2, 4, 6),
                 ymin = c(1, 3, 2),
                 ymax = c(2.5, 5, 6))
base <- ggplot(df, aes(x, y, xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax)) +
  labs(x = NULL, y = NULL)

base + geom_rect(alpha = 0.5) + ggtitle("rect")
base + geom_ribbon() + ggtitle("ribbon")
base + geom_errorbar() + ggtitle("errorbar")
base + geom_pointrange() + ggtitle("pointrange")
```

## Summarizing geoms

And then there are the basic statistical summary geoms:

```{r ss-geoms, message=FALSE, fig.show="hold", out.width="50%"}
base <- ggplot(mpg, aes(fill = class)) +
  labs(x = NULL, y = NULL) +
  theme(legend.position = "none")

base + geom_histogram(aes(x = displ)) + ggtitle("histogram")
base + geom_density(aes(x = displ)) + ggtitle("density")
base + geom_freqpoly(aes(x = displ)) + ggtitle("freqpoly")
base + geom_boxplot(aes(x = class, y = displ)) + ggtitle("boxplot")
base + geom_violin(aes(x = class, y = displ)) + ggtitle("violin")
base + geom_dotplot(aes(x = class)) + ggtitle("dotplot")
```

Note that geoms can build on each other:

* `geom_histogram()` uses `geom_bar()` but a different statistical summary, `stat_bin()`
* `geom_smooth()` (not shown above) uses `geom_line()` and `geom_ribbon()`

## Overplotting

When you have so many data points that they're obscuring each other, it's a problem---statistical relationship can be obscured, and the viewer can no longer see the data distribution(s).

At low to moderate data densities, try changing your plot symbol:

```{r overplot1, fig.show="hold", out.width="50%"}
# Example from https://ggplot2-book.org/statistical-summaries.html#overplotting
df <- data.frame(x = rnorm(4000), y = rnorm(4000))
norm <- ggplot(df, aes(x, y)) + 
  labs(x = NULL, y = NULL) 

norm + geom_point()
norm + geom_point(shape = 1) # Hollow circles
norm + geom_point(shape = ".") # Pixel sized
norm + geom_point(alpha = 0.1) # Pixel sized
```

At higher data densities you'll need two-dimensional density geoms:

```{r overplot2, fig.show="hold", out.width="50%"}
norm + geom_bin2d() + ggtitle("bin2d")
norm + geom_hex() + ggtitle("hex")
norm + geom_hex(bins = 10) + ggtitle("hex (bins = 10)")
norm + geom_density2d() + ggtitle("density2d")

theme_set(thm)
```


# Geoms and stats

**Every geom has a default stat, and every stat has a default geom.**

Most stats take additional parameters to specify the details of statistical transformation; these are usually supplied in `...` (in which case stat and geom parameters are automatically teased apart).


## Geom defaults

The different behavior of different geoms can be seen from their parameter defaults:

Parameter                | `geom_point` | `geom_boxplot` | `geom_histogram` | `geom_abline`
------------------------ | ------------ | -------------- | ---------------- | -------------
mapping                  | NULL         | NULL           | NULL             | NULL
data                     | NULL         | NULL           | NULL             | NULL
stat                     | "identity"   | "boxplot"      | "bin"            | NULL
position                 | "identity"   | "dodge2"       | "stack"          | NULL
show.legend              | NA           | NA             | NA               | NA
inherit.aes              | TRUE         | TRUE           | TRUE             | FALSE



## Changing the `stat`

Geoms have their stats, and stats have their geoms. But we can use alternate stats within geoms, and alternate geoms within stats:

```{r alternate-stat, fig.show="hold", out.width="50%"}
theme_update(title = element_text(size = 20, face = "bold"))
base <- ggplot(mpg, aes(displ, hwy))
base + geom_point() + ggtitle("geom_point")
base + geom_point(stat = "ecdf") + 
  ggtitle('geom_point(stat = "ecdf")')
ggplot(mpg, aes(displ, hwy)) + stat_ecdf() + ggtitle("stat_ecdf")
ggplot(mpg, aes(displ, hwy)) + stat_ecdf(geom = "point") +
  ggtitle('stat_ecdf(geom = "point")')
theme_set(thm)
```

We can also use `stat_summary()`, a wonderful all-purpose tool.

For example, what if we'd like to plot data within groups, but also display the group mean? We could summarize the data separately, and then add second `geom_point(data = ...)` call, but there's a slicker way.

```{r stat-summary}
ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  # stat_summary(fun = "mean", geom = "point", color = "red", size = 4)
  geom_point(stat = "summary", fun = "mean", color = "red", size = 4)
```

You might ask whether the summary point can be assigned a color corresponding to the mean of its group---i.e., whether we can use `stat_summary` to compute _both_ `mean(hwy)` and `mean(displ)`. As far as I know this is not possible; you would need to pre-compute a separate summary dataset:

```{r mpg-agg}
mpg_agg <- aggregate(list(hwy = mpg$hwy, displ = mpg$displ),
                     by = list(class = mpg$class), mean)
ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  geom_point(data = mpg_agg, size = 4)
```


## EXERCISE: stat_summary

In addition to using built-in functions like `mean` that return a single value, `stat_summary` can use a user-provided function that returns three values:

>`fun.data`: A function that is given the complete data and should return a data frame with variables ymin, y, and ymax.

**Starting from the code above, write a custom summary function to produce the following graph:**

```{r exercise-stat-summary, echo=FALSE}
my_smry <- function(y) { 
  ysd <- sd(y, na.rm = TRUE)
  ymn <- mean(y, na.rm = TRUE)
  data.frame(y = ymn, ymin = ymn - ysd, ymax = ymn + ysd)
}

ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  geom_pointrange(stat = "summary", fun.data = "my_smry", color = "red")
```

# Scales

From the ggplot2 [book](https://ggplot2-book.org/scales-guides.html#scales-guides):

>Formally, each scale is a function from a region in data space (the domain of the scale) to a region in aesthetic space (the range of the scale). The axis or legend is the inverse function: it allows you to convert visual properties back to data.

* Every aesthetic in a plot is associated with exactly one scale.
* The default scale depends on the aesthetic and the variable type. 
* If you supply two scales for the same aesthetic, the last takes precedence.
* Scale functions are of the form `scale_<aesthetic>_<type of scale>()`
* There are continuous scales, discrete scales, and _binned_ scales

## Changing scales {.tabset}

Continuous and discrete scale functions have some parameters that are often used:

* `name` - change the title of the axis or legend
* `breaks` - tick locations (on an axis) or legend keys
* `labels` - customize labels on ticks or legend keys
* `limits` - change the scale range

NOTE that the `limits` argument will **drop data** outside of the new limits, because of where this happens in the ggplot2 pipeline; see above.

### cars

```{r scale-changes0}
base <- ggplot(cars, aes(speed, dist)) + geom_point()
base
```

### `name`

```{r scale-changes1}
base + scale_x_continuous(name = "New name")
```

### `breaks`

```{r scale-changes2}
base + scale_x_continuous(breaks = c(7, 12, 13, 18, 24))
```

### `labels`

```{r scale-changes3}
base + scale_x_continuous(labels = c("", "This", "isn't", "a", "good", "idea"))
```

### `limits`

**Notice the warning that occurs here. Why?**

Because by default, ggplot2 converts data outside the scale limits to NA, which can affect subsequent stats and geoms. This behavior can be changed; see `scales::oob`.

```{r scale-changes4}
base + scale_x_continuous(limits = c(10, 20))
```

## Scale labels

The example above used a manually specified vector of labels. We can also use a _labelling function_. We can write our own, but the `scales` package provides some really useful ones:

```{r labeller-functions, warning=FALSE, fig.show='hold', results='hold'}
library(scales)

label_dollar()(2004)
label_comma()(2004)
label_percent()(2004)
label_bytes()(2004)

ggplot(cars, aes(speed, dist, color = speed)) + 
  geom_point() +
  scale_x_continuous(labels = label_percent()) +
  scale_y_continuous(labels = label_dollar()) +
  scale_color_continuous(labels = label_ordinal())
```

## Math

We can include arbitrary mathematical expression in almost any text in ggplot2: axis and legend titles, facet titles, legend entries. This uses R's `plotmath()` facility and interprets a text argument as a mathematical expression. 

[This page](https://astrostatistics.psu.edu/su07/R/html/grDevices/html/plotmath.html) has a handy list of plotmath examples; see also `?plotmath`.

How this is implemented in ggplot2 can feel frustratingly arbitrary, and I find myself experimenting and googling a lot:

```{r plotmath}
ggplot(mpg, aes(displ, hwy, color = class)) + geom_point() +
  # Axis labels will parse expressions by default
  xlab(expression(paste(Displacement~hat(x), " (in", phantom()^3, ")"))) +
  # Another way
  labs(y = quote(Highway~(mu))) +
  scale_color_discrete(labels = c(expression(alpha), 
                                  expression(beta), 
                                  expression(gamma)))
```

It is also possible to include Markdown in axis and legend titles using the `ggtext` package.

```{r markdown, fig.show="hold", out.width="50%", warning=FALSE}
library(ggtext)
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + 
  geom_point() + 
  labs(x = "Axis title with *italics* and **boldface**") +
  theme(axis.title.x = element_text(size = 20))

base 
base + theme(axis.title.x = ggtext::element_markdown())
```


## Scale transformations

Continuous data are by default mapped linearly from the data space onto the aesthetic space, but this can be overridden using transformations via the `trans` argument:

| Name      | Function $f(x)$         | Inverse $f^{-1}(y)$
|-----------|-------------------------|------------------------
| exp       | $e ^ x$                 | $\log(y)$
| identity  | $x$                     | $y$
| log       | $\log(x)$               | $e ^ y$
| log10     | $\log_{10}(x)$          | $10 ^ y$
| logit     | $\log(\frac{x}{1 - x})$ | $\frac{1}{1 + e(y)}$
| pow10     | $10^x$                  | $\log_{10}(y)$
| sqrt      | $x^{1/2}$               | $y ^ 2$

For many of these there are three ways to accomplish a scale-transformation task, e.g.:

* `scale_x_continuous(trans = "log10")`
* `scale_x_log10()`
* `aes(log10(x), ...)`

These all do the same thing, transforming the data _before_ any statistical summaries. Axis labeling may change however:

* if you use a transformed scale, the axes will be labelled in the original data space
* if you transform the data, the axes will be labelled in the transformed space.

```{r scale-transform, fig.show="hold", out.width="50%"}
# untransformed
theme_update(axis.text.y = element_text(size = 20, face = "bold"),
             title = element_text(size = 20, face = "bold"))
df <- data.frame(x = 1:50, y = 1:50)

ggplot(df, aes(x, y, group = 1)) + 
  geom_boxplot() + geom_point() + 
  ggtitle("untransformed")

# manual transformation
ggplot(df, aes(x, log10(y), group = 1)) + 
  geom_boxplot() + geom_point() + 
  ggtitle("aes(log10(y))")

# transform using scales
ggplot(df, aes(x, y, group = 1)) + 
  geom_boxplot() + geom_point() + 
  scale_y_continuous(trans = "log10") + 
  ggtitle('trans = "log10"')

# coordinate transformation
ggplot(df, aes(x, y, group = 1)) + 
  geom_boxplot() + geom_point() + 
  coord_trans(y = "log10") +
  ggtitle('coord_trans(y = "log10")') + drk
theme_set(thm)
```

Less common is to transform color or size scales. An example from the [ggplot2 book](https://ggplot2-book.org/scales-guides.html#scale-transformation-extras):

```{r color-transform, fig.show="hold", out.width="50%"}
base <- ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  scale_x_continuous(NULL, NULL, expand = c(0, 0)) +
  scale_y_continuous(NULL, NULL, expand = c(0, 0))

base
base + scale_fill_continuous(trans = "sqrt")
```

## Discrete scales

Generally ggplot will automatically map categorical data to a discrete scale, and we don't have to think further about it.

I didn't know that you can selectively replace categorical labels:

```{r}
ggplot(mpg, aes(x = hwy, y = class)) + 
  geom_point() + 
  scale_y_discrete(labels = c(midsize = "Ben's car"))
```

## Binned scales

I did not know these existed! They do.

```{r binned-scale, fig.show="hold", out.width="50%"}
base <- ggplot(mpg, aes(hwy, class)) + geom_count()

base 
base + scale_x_binned(n.breaks = 10)
```

## Color

"People do crap colors."  - S. Pennington

Functions like `scale_color_discrete()` map each group to an evenly spaced hue on the color wheel.

TODO

# Guides

Legends and axes are collectively referred to as "guides" in the ggplot2 system, and are the inverse of scales: they map visual properties back to the underlying data.


# Coordinate systems

Most often we work with the default Cartesian coordinate system, `coord_cartesian()`. Two other common and useful systems are:

* `coord_flip()` flips the x and y axes. Note that this is _not_ the same thing as plotting y against x
* `coord_fixed()` is the Cartesian system with a fixed aspect ratio

There are also specialized _non-linear coordinate systems_, in which the closest distance between two points may no longer be a straight line. These systems may thus change the very shape of geoms.

* `coord_map()` and `coord_sf()` and for map projections
* `coord_polar()` produces polar coordinates
* `coord_trans()` allows you to apply arbitrary transformations to x and y

```{r funky-rect, fig.show="hold", out.width="50%"}
rect <- data.frame(x = 50, y = 50)
line <- data.frame(x = c(1, 200), y = c(100, 1))
base <- ggplot(mapping = aes(x, y)) + 
  geom_tile(data = rect, aes(width = 50, height = 50)) + 
  geom_line(data = line) + 
  xlab(NULL) + ylab(NULL)
base + ggtitle("Cartesian")
base + coord_flip() + ggtitle("coord_flip")
base + coord_polar("x") + ggtitle("Polar x")
base + coord_trans(y = "log10") + ggtitle('coord_trans(y = "log10")')
```

(Modified from an [example](https://ggplot2-book.org/coord.html#coord-non-linear) in the ggplot2 book.)

## EXERCISE: coordinate flipping

Is flipping the x and y coordinates the same thing as exchanging the x and y aesthetic mappings? 

**Use the `cars` dataset and `geom_smooth()` to test this.**

```{r coord-flip, fig.show="hold", out.width="50%", message=FALSE}
p <- ggplot(cars, aes(speed, dist)) + geom_point() + geom_smooth()
p
p + coord_flip()
ggplot(cars, aes(dist, speed)) + geom_point() + geom_smooth() + drk
```

## Coordinate limits

**'Zooming into' a part of the plot is a coordinate transform, not a scale adjustment.**

`coord_cartesian(xlim = c(x1, x2))`

`coord_cartesian(ylim = c(y1, y2))`

`coord_cartesian(xlim = c(x1, x2), ylim = c(y1, y2))`

```{r zoom, fig.show="hold", out.width="50%", message=FALSE, warning=FALSE}
theme_update(title = element_text(size = 20, face = "bold"))

p <- ggplot(mpg, aes(displ, cty)) + geom_point() + geom_smooth()
p + geom_vline(xintercept = 4, linetype = 2) + geom_vline(xintercept = 6, linetype = 2)
p + xlim(c(4, 6)) + drk + ggtitle("xlim")
p + scale_x_continuous(limits = c(4, 6)) + drk + ggtitle("scale limits")
p + coord_cartesian(xlim = c(4, 6)) + ggtitle("coord_cartesian")
theme_set(thm)
```

# Annotations

Labeling points

Shading

```{r economics}
pres <- subset(presidential, start >= economics$date[1])

ggplot(economics) + 
  geom_rect(data = pres, 
            alpha = 0.3, 
            # notice the "-Inf" and "Inf" y limits here
            aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf, fill = party)) +
  geom_line(aes(date, unemploy / pop)) + 
  scale_fill_manual(values = c("blue", "red")) +
  scale_y_continuous(labels = label_percent()) +
  geom_text(data = pres, angle = 30, size = 3, hjust = 0, nudge_x = 50,
            aes(x = start, y = 0.025, label = name))
```

The `ggrepel` package provides a useful variant on `geom_text` that attempts to space text labels out nicely:

```{r, fig.show="hold", out.width="50%"}
base <- ggplot(mtcars,
  aes(wt, mpg, label = rownames(mtcars), colour = factor(cyl))) +
  geom_point() + 
  theme(legend.position = "none")

base + geom_text()
base + ggrepel::geom_text_repel()
```

The `ggforce` package for example:

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) + 
  ggforce::geom_mark_ellipse(aes(label = cyl, group = cyl))
```

