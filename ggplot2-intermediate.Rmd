---
title: "Data visualization using ggplot2 (intermediate)"
author: "BBL"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    code_folding: hide
---

The introductory workshop material is here: [Part 1](https://rpubs.com/bpbond/727254), [Part 2](https://rpubs.com/bpbond/727256).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(emo)  # install via devtools::install_github("hadley/emo")
library(ggplot2)
thm <- theme_minimal()
theme_set(thm)
drk <- theme(panel.background = element_rect(fill = "gray"))
```

TODO
* more worked examples/exercises?


# Topics

* The ggplot2 pipeline
* Plot layers
* The relationship between stats and geoms
* Scales
* Coordinate transformations


**Goal: .**

# The ggplot2 pipeline


[Figure 13.2 from the ggplot2 book](https://ggplot2-book.org/mastery.html#fig:schematic)

![](https://ggplot2-book.org/diagrams/mastery-schema.png)


# Assumptions

<span style="color: red;">**We assume you're familiar with the basic mechanics of ggplot2**</span> as covered in the introductory workshop:

* Data visualization concepts
* Grammar of graphics
* Building a plot: dataset structure, `ggplot()`, aesthetics, geoms, labels, themes, facets
* Aesthetic and theme inheritance principles


# Plot layers

We think of geoms as layers, and that's usually true, what actually makes up a _plot layer_?

* An optional **mapping** of aesthetics that supplements or overrides the default mapping set in `ggplot()`
* An optional **dataset** that overrides the default plot dataset
* A **geom**: the geometric object used to draw each observation
* A **stat**: the statistical transformation to use (even if it's only the “identity” stat)
* A **position** used to adjust overlapping objects

TODO - figure showing computational pipeline

With this we can start to truly understand the [usage of `geom_point()`](https://ggplot2.tidyverse.org/reference/geom_point.html) for example:
```
geom_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
```

## geom defaults

The different behavior of different geoms can be seen from their parameter defaults:

Parameter                | `geom_point` | `geom_boxplot` | `geom_histogram` | `geom_abline`
------------------------ | ------------ | -------------- | ---------------- | -------------
mapping                  | NULL         | NULL           | NULL             | NULL
data                     | NULL         | NULL           | NULL             | NULL
stat                     | "identity"   | "boxplot"      | "bin"            | NULL
position                 | "identity"   | "dodge2"       | "stack"          | NULL
show.legend              | NA           | NA             | NA               | NA
inherit.aes              | TRUE         | TRUE           | TRUE             | FALSE


## stats and geoms

You can pass params in ... (in which case stat and geom parameters are automatically teased apart)

**Every geom has a default stat, and every stat has a default geom.**

Most stats take additional parameters to specify the details of statistical transformation. You can supply params either in ... (in which case stat and geom parameters are automatically teased apart), or in a list called stat_params.

### Changing the stat

TODO

```{r}
ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  # stat_summary(fun = "mean", geom = "point", color = "red", size = 4)
  geom_point(stat = "summary", fun = "mean", color = "red", size = 4)
```

You might ask whether the summary point can be assigned a color corresponding to the mean of its group---i.e., whether we can use `stat_summary` to compute _both_ `mean(hwy)` and `mean(displ)`. As far as I know this is not possible; you would need to pre-compute a separate summary dataset:

```{r}
mpg_agg <- aggregate(list(hwy = mpg$hwy, displ = mpg$displ),
                     by = list(class = mpg$class), mean)
ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  geom_point(data = mpg_agg, size = 4)
```


### EXERCISE: stat_summary

In addition to using built-in functions like `mean` that return a single value, `stat_summary` can use a user-provided function that return three values:

>`fun.data`: A function that is given the complete data and should return a data frame with variables ymin, y, and ymax.

**Starting from the code above, write a custom summary function to produce the following graph:**

```{r exercise-stat-summary, echo=FALSE}
my_smry <- function(y) { 
  ysd <- sd(y, na.rm = TRUE)
  ymn <- mean(y, na.rm = TRUE)
  data.frame(y = ymn, ymin = ymn - ysd, ymax = ymn + ysd)
}

ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  geom_pointrange(stat = "summary", fun.data = "my_smry", color = "red")
```
```{r, eval=FALSE}
my_smry <- function(y) { 
  ysd <- sd(y, na.rm = TRUE)
  ymn <- mean(y, na.rm = TRUE)
  data.frame(y = ymn, ymin = ymn - ysd, ymax = ymn + ysd)
}

ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  geom_pointrange(stat = "summary", fun.data = "my_smry", color = "red")
```

# Scales

From the ggplot2 [book](https://ggplot2-book.org/scales-guides.html#scales-guides):

>Formally, each scale is a function from a region in data space (the domain of the scale) to a region in aesthetic space (the range of the scale). The axis or legend is the inverse function: it allows you to convert visual properties back to data.

* Every aesthetic in a plot is associated with exactly one scale.
* The default scale depends on the aesthetic and the variable type. 
* If you supply two scales for the same aesthetic, the last takes precedence.
* Scale functions are of the form `scale_<aesthetic>_<type of scale>()`
* There are continuous scales, discrete scales, and _binned_ scales

## Scale transformations

10.1.9
When working with continuous data, the default is to map linearly from the data space onto the aesthetic space. It is possible to override this default using transformations. Every continuous scale takes a trans argument, allowing the use of a variety of transformations:

| Name      | Function $f(x)$         | Inverse $f^{-1}(y)$
|-----------|-------------------------|------------------------
| exp       | $e ^ x$                 | $\log(y)$
| identity  | $x$                     | $y$
| log       | $\log(x)$               | $e ^ y$
| log10     | $\log_{10}(x)$          | $10 ^ y$
| logit     | $\log(\frac{x}{1 - x})$ | $\frac{1}{1 + e(y)}$
| pow10     | $10^x$                  | $\log_{10}(y)$
| sqrt      | $x^{1/2}$               | $y ^ 2$

For many of these there are three ways to accomplish a scale-transformation task, e.g.:

* `scale_x_continuous(trans = "log10")`
* `scale_x_log10()`
* `aes(log10(x), ...)`

These all do the same thing, transforming the data _before_ any statistical summaries. Axis labeling may change however:

* if you use a transformed scale, the axes will be labelled in the original data space
* if you transform the data, the axes will be labelled in the transformed space.

```{r scale-transform, fig.show="hold", out.width="50%"}
# untransformed
theme_update(axis.text.x = element_text(size = 20, face = "bold"),
             title = element_text(size = 20, face = "bold"))
df <- data.frame(x = 1:50, y = 1:50)

ggplot(df, aes(x, x)) + 
  geom_point() + ggtitle("untransformed")

# manual transformation
ggplot(df, aes(log10(x), y)) + 
  geom_point() + ggtitle("aes(log10(x)")

# transform using scales
ggplot(df, aes(x, y)) + 
  geom_point() + 
  scale_x_continuous(trans = "log10") + ggtitle('trans = "log10"')

# coordinate transformation
ggplot(df, aes(x, y)) + 
  geom_point() + 
  coord_trans(x = "log10") +
  ggtitle('coord_trans(x = "log10")') + drk
theme_set(thm)
```

Less common is to transform color or size scales. An example from the [ggplot2 book](https://ggplot2-book.org/scales-guides.html#scale-transformation-extras):

```{r color-transform, fig.show="hold", out.width="50%"}
base <- ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  scale_x_continuous(NULL, NULL, expand = c(0, 0)) +
  scale_y_continuous(NULL, NULL, expand = c(0, 0))

base
base + scale_fill_continuous(trans = "sqrt")
```

## Discrete scales

Generally ggplot will automatically map categorical data to a discrete scale, and we don't have to think further about it.

I didn't know that you can selectively replace categorical labels:

```{r}
ggplot(mpg, aes(x = hwy, y = class)) + 
  geom_point() + 
  scale_y_discrete(labels = c(midsize = "Ben's car"))
```

## Binned scales

I did not know these existed! They do.

```{r binned-scale, fig.show="hold", out.width="50%"}
base <- ggplot(mpg, aes(hwy, class)) + geom_count()

base 
base + scale_x_binned(n.breaks = 10)
```

## Color

"People do crap colors."  - S. Pennington

TODO

# Coordinate systems

Most often we work with the default Cartesian coordinate system, `coord_cartesian()`. Two other common and useful systems are:

* `coord_flip()` flips the x and y axes. Note that this is _not_ the same thing as plotting y against x
* `coord_fixed()` is the Cartesian system with a fixed aspect ratio

There are also specialized _non-linear coordinate systems_, in which the closest distance between two points may no longer be a straight line. These systems may thus change the very shape of geoms.

* `coord_map()` and `coord_sf()` and for map projections
* `coord_polar()` produces polar coordinates
* `coord_trans()` allows you to apply arbitrary transformations to x and y

```{r, fig.show="hold", out.width="50%"}
rect <- data.frame(x = 50, y = 50)
line <- data.frame(x = c(1, 200), y = c(100, 1))
base <- ggplot(mapping = aes(x, y)) + 
  geom_tile(data = rect, aes(width = 50, height = 50)) + 
  geom_line(data = line) + 
  xlab(NULL) + ylab(NULL)
base + ggtitle("Cartesian")
base + coord_flip() + ggtitle("coord_flip")
base + coord_polar("x") + ggtitle("Polar x")
base + coord_trans(y = "log10") + ggtitle('coord_trans(y = "log10")')
```

(Modified from an [example](https://ggplot2-book.org/coord.html#coord-non-linear) in the ggplot2 book.)

## EXERCISE: coordinate flipping

Is flipping the x and y coordinates the same thing as exchanging the x and y aesthetic mappings? 

**Use the `cars` dataset and `geom_smooth()` to test this.**

```{r coord-flip, fig.show="hold", out.width="50%", message=FALSE}
p <- ggplot(cars, aes(speed, dist)) + geom_point() + geom_smooth()
p
p + coord_flip()
ggplot(cars, aes(dist, speed)) + geom_point() + geom_smooth() + drk
```

## Coordinate limits

**'Zooming into' a part of the plot is a coordinate transform, not a scale adjustment.**

`coord_cartesian(xlim = c(x1, x2))`

`coord_cartesian(ylim = c(y1, y2))`

`coord_cartesian(xlim = c(x1, x2), ylim = c(y1, y2))`

```{r zoom, fig.show="hold", out.width="50%", message=FALSE, warning=FALSE}
theme_update(title = element_text(size = 20, face = "bold"))

p <- ggplot(mpg, aes(displ, cty)) + geom_point() + geom_smooth()
p + geom_vline(xintercept = 4, linetype = 2) + geom_vline(xintercept = 6, linetype = 2)
p + xlim(c(4, 6)) + drk + ggtitle("xlim")
p + scale_x_continuous(limits = c(4, 6)) + drk + ggtitle("scale limits")
p + coord_cartesian(xlim = c(4, 6)) + ggtitle("coord_cartesian")
theme_set(thm)
```


