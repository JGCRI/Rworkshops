---
title: "Data visualization using ggplot2 (intermediate)"
author: "BBL"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    code_folding: hide
---

The introductory workshop material is here: [Part 1](https://rpubs.com/bpbond/727254), [Part 2](https://rpubs.com/bpbond/727256).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(emo)  # install via devtools::install_github("hadley/emo")
library(ggplot2)
thm <- theme_minimal()
theme_set(thm)
drk <- theme(panel.background = element_rect(fill = "gray"))
```

TODO

* more worked examples/exercises?


# Topics

* The ggplot2 pipeline
* Plot layers
* The relationship between stats and geoms
* Scales
* Coordinate transformations


**Goal: .**

# The ggplot2 pipeline


[Figure 13.2 from the ggplot2 book](https://ggplot2-book.org/mastery.html#fig:schematic)

![](https://ggplot2-book.org/diagrams/mastery-schema.png)


# Assumptions

<span style="color: red;">**We assume you're familiar with the basic mechanics of ggplot2**</span> as covered in the introductory workshop:

* Data visualization concepts
* Grammar of graphics
* Building a plot: dataset structure, `ggplot()`, aesthetics, geoms, labels, themes, facets
* Aesthetic and theme inheritance principles


# Plot layers

We think of geoms as layers, and that's usually true, what actually makes up a _plot layer_?

* An optional **mapping** of aesthetics that supplements or overrides the default mapping set in `ggplot()`
* An optional **dataset** that overrides the default plot dataset
* A **geom**: the geometric object used to draw each observation
* A **stat**: the statistical transformation to use (even if it's only the “identity” stat)
* A **position** used to adjust overlapping objects

TODO - figure showing computational pipeline

With this we can start to truly understand the [usage of `geom_point()`](https://ggplot2.tidyverse.org/reference/geom_point.html) for example:
```
geom_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
```


# Geoms and stats

You can pass params in ... (in which case stat and geom parameters are automatically teased apart)

Most stats take additional parameters to specify the details of statistical transformation. You can supply params either in ... (in which case stat and geom parameters are automatically teased apart), or in a list called stat_params.


**Every geom has a default stat, and every stat has a default geom.**

## geom defaults

The different behavior of different geoms can be seen from their parameter defaults:

Parameter                | `geom_point` | `geom_boxplot` | `geom_histogram` | `geom_abline`
------------------------ | ------------ | -------------- | ---------------- | -------------
mapping                  | NULL         | NULL           | NULL             | NULL
data                     | NULL         | NULL           | NULL             | NULL
stat                     | "identity"   | "boxplot"      | "bin"            | NULL
position                 | "identity"   | "dodge2"       | "stack"          | NULL
show.legend              | NA           | NA             | NA               | NA
inherit.aes              | TRUE         | TRUE           | TRUE             | FALSE



### Changing the `stat`

Geoms have their stats, and stats have their geoms. But we can use alternate stats within geoms, and alternate geoms within stats:

```{r alternate-stat, fig.show="hold", out.width="50%"}
theme_update(title = element_text(size = 20, face = "bold"))
base <- ggplot(mpg, aes(displ, hwy))
base + geom_point() + ggtitle("geom_point")
base + geom_point(stat = "ecdf") + 
  ggtitle('geom_point(stat = "ecdf")')
ggplot(mpg, aes(displ, hwy)) + stat_ecdf() + ggtitle("stat_ecdf")
ggplot(mpg, aes(displ, hwy)) + stat_ecdf(geom = "point") +
  ggtitle('stat_ecdf(geom = "point")')
theme_set(thm)
```

We can also use `stat_summary()`, a wonderful all-purpose tool.

For example, what if we'd like to plot data within groups, but also display the group mean? We could summarize the data separately, and then add second `geom_point(data = ...)` call, but there's a slicker way.

```{r stat-summary}
ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  # stat_summary(fun = "mean", geom = "point", color = "red", size = 4)
  geom_point(stat = "summary", fun = "mean", color = "red", size = 4)
```

You might ask whether the summary point can be assigned a color corresponding to the mean of its group---i.e., whether we can use `stat_summary` to compute _both_ `mean(hwy)` and `mean(displ)`. As far as I know this is not possible; you would need to pre-compute a separate summary dataset:

```{r mpg-agg}
mpg_agg <- aggregate(list(hwy = mpg$hwy, displ = mpg$displ),
                     by = list(class = mpg$class), mean)
ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  geom_point(data = mpg_agg, size = 4)
```


### EXERCISE: stat_summary

In addition to using built-in functions like `mean` that return a single value, `stat_summary` can use a user-provided function that returns three values:

>`fun.data`: A function that is given the complete data and should return a data frame with variables ymin, y, and ymax.

**Starting from the code above, write a custom summary function to produce the following graph:**

```{r exercise-stat-summary, echo=FALSE}
my_smry <- function(y) { 
  ysd <- sd(y, na.rm = TRUE)
  ymn <- mean(y, na.rm = TRUE)
  data.frame(y = ymn, ymin = ymn - ysd, ymax = ymn + ysd)
}

ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  geom_pointrange(stat = "summary", fun.data = "my_smry", color = "red")
```
```{r, eval=FALSE}
my_smry <- function(y) { 
  ysd <- sd(y, na.rm = TRUE)
  ymn <- mean(y, na.rm = TRUE)
  data.frame(y = ymn, ymin = ymn - ysd, ymax = ymn + ysd)
}

ggplot(mpg, aes(class, hwy, color = displ)) + 
  geom_jitter() + 
  geom_pointrange(stat = "summary", fun.data = "my_smry", color = "red")
```

# Scales

From the ggplot2 [book](https://ggplot2-book.org/scales-guides.html#scales-guides):

>Formally, each scale is a function from a region in data space (the domain of the scale) to a region in aesthetic space (the range of the scale). The axis or legend is the inverse function: it allows you to convert visual properties back to data.

* Every aesthetic in a plot is associated with exactly one scale.
* The default scale depends on the aesthetic and the variable type. 
* If you supply two scales for the same aesthetic, the last takes precedence.
* Scale functions are of the form `scale_<aesthetic>_<type of scale>()`
* There are continuous scales, discrete scales, and _binned_ scales

## Changing scales {.tabset}

Continuous and discrete scale functions have some parameters that are often used:

* `name` - change the title of the axis or legend
* `breaks` - tick locations (on an axis) or legend keys
* `labels` - customize labels on ticks or legend keys
* `limits` - change the scale range

NOTE that the `limits` argument will **drop data** outside of the new limits, because of where this happens in the ggplot2 pipeline; see above.

### cars

```{r scale-changes0}
base <- ggplot(cars, aes(speed, dist)) + geom_point()
base
```

### `name`

```{r scale-changes1}
base + scale_x_continuous(name = "New name")
```

### `breaks`

```{r scale-changes2}
base + scale_x_continuous(breaks = c(7, 12, 13, 18, 24))
```

### `labels`

```{r scale-changes3}
base + scale_x_continuous(labels = c("", "This", "isn't", "a", "good", "idea"))
```

### `limits`

```{r scale-changes4}
base + scale_x_continuous(limits = c(10, 20))
```

**Notice the warning that occurs here. Why?**

Because by default, ggplot2 converts data outside the scale limits to NA, which can affect subsequent stats and geoms.

## Scale labels

The example above used a manually specified vector of labels. We can also use a _labelling function_. We can write our own, but the `scales` package provides some really useful ones:

```{r labeller-functions, warning=FALSE, fig.show='hold', results='hold'}
library(scales)

label_dollar()(2004)
label_comma()(2004)
label_percent()(2004)
label_bytes()(2004)

ggplot(cars, aes(speed, dist, color = speed)) + 
  geom_point() +
  scale_x_continuous(labels = label_percent()) +
  scale_y_continuous(labels = label_dollar()) +
  scale_color_continuous(labels = label_ordinal())
```


## Scale transformations

Continuous data are by default mapped linearly from the data space onto the aesthetic space, but this can be overridden using transformations via the `trans` argument:

| Name      | Function $f(x)$         | Inverse $f^{-1}(y)$
|-----------|-------------------------|------------------------
| exp       | $e ^ x$                 | $\log(y)$
| identity  | $x$                     | $y$
| log       | $\log(x)$               | $e ^ y$
| log10     | $\log_{10}(x)$          | $10 ^ y$
| logit     | $\log(\frac{x}{1 - x})$ | $\frac{1}{1 + e(y)}$
| pow10     | $10^x$                  | $\log_{10}(y)$
| sqrt      | $x^{1/2}$               | $y ^ 2$

For many of these there are three ways to accomplish a scale-transformation task, e.g.:

* `scale_x_continuous(trans = "log10")`
* `scale_x_log10()`
* `aes(log10(x), ...)`

These all do the same thing, transforming the data _before_ any statistical summaries. Axis labeling may change however:

* if you use a transformed scale, the axes will be labelled in the original data space
* if you transform the data, the axes will be labelled in the transformed space.

```{r scale-transform, fig.show="hold", out.width="50%"}
# untransformed
theme_update(axis.text.y = element_text(size = 20, face = "bold"),
             title = element_text(size = 20, face = "bold"))
df <- data.frame(x = 1:50, y = 1:50)

ggplot(df, aes(x, y, group = 1)) + 
  geom_boxplot() + geom_point() + 
  ggtitle("untransformed")

# manual transformation
ggplot(df, aes(x, log10(y), group = 1)) + 
  geom_boxplot() + geom_point() + 
  ggtitle("aes(log10(y))")

# transform using scales
ggplot(df, aes(x, y, group = 1)) + 
  geom_boxplot() + geom_point() + 
  scale_y_continuous(trans = "log10") + 
  ggtitle('trans = "log10"')

# coordinate transformation
ggplot(df, aes(x, y, group = 1)) + 
  geom_boxplot() + geom_point() + 
  coord_trans(y = "log10") +
  ggtitle('coord_trans(y = "log10")') + drk
theme_set(thm)
```

Less common is to transform color or size scales. An example from the [ggplot2 book](https://ggplot2-book.org/scales-guides.html#scale-transformation-extras):

```{r color-transform, fig.show="hold", out.width="50%"}
base <- ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  scale_x_continuous(NULL, NULL, expand = c(0, 0)) +
  scale_y_continuous(NULL, NULL, expand = c(0, 0))

base
base + scale_fill_continuous(trans = "sqrt")
```

## Discrete scales

Generally ggplot will automatically map categorical data to a discrete scale, and we don't have to think further about it.

I didn't know that you can selectively replace categorical labels:

```{r}
ggplot(mpg, aes(x = hwy, y = class)) + 
  geom_point() + 
  scale_y_discrete(labels = c(midsize = "Ben's car"))
```

## Binned scales

I did not know these existed! They do.

```{r binned-scale, fig.show="hold", out.width="50%"}
base <- ggplot(mpg, aes(hwy, class)) + geom_count()

base 
base + scale_x_binned(n.breaks = 10)
```

## Color

"People do crap colors."  - S. Pennington

Functions like `scale_color_discrete()` map each group to an evenly spaced hue on the color wheel.

TODO

# Guides

Legends and axes are collectively referred to as "guides" in the ggplot2 system, and are the inverse of scales: they map visual properties back to the underlying data.




# Coordinate systems

Most often we work with the default Cartesian coordinate system, `coord_cartesian()`. Two other common and useful systems are:

* `coord_flip()` flips the x and y axes. Note that this is _not_ the same thing as plotting y against x
* `coord_fixed()` is the Cartesian system with a fixed aspect ratio

There are also specialized _non-linear coordinate systems_, in which the closest distance between two points may no longer be a straight line. These systems may thus change the very shape of geoms.

* `coord_map()` and `coord_sf()` and for map projections
* `coord_polar()` produces polar coordinates
* `coord_trans()` allows you to apply arbitrary transformations to x and y

```{r, fig.show="hold", out.width="50%"}
rect <- data.frame(x = 50, y = 50)
line <- data.frame(x = c(1, 200), y = c(100, 1))
base <- ggplot(mapping = aes(x, y)) + 
  geom_tile(data = rect, aes(width = 50, height = 50)) + 
  geom_line(data = line) + 
  xlab(NULL) + ylab(NULL)
base + ggtitle("Cartesian")
base + coord_flip() + ggtitle("coord_flip")
base + coord_polar("x") + ggtitle("Polar x")
base + coord_trans(y = "log10") + ggtitle('coord_trans(y = "log10")')
```

(Modified from an [example](https://ggplot2-book.org/coord.html#coord-non-linear) in the ggplot2 book.)

## EXERCISE: coordinate flipping

Is flipping the x and y coordinates the same thing as exchanging the x and y aesthetic mappings? 

**Use the `cars` dataset and `geom_smooth()` to test this.**

```{r coord-flip, fig.show="hold", out.width="50%", message=FALSE}
p <- ggplot(cars, aes(speed, dist)) + geom_point() + geom_smooth()
p
p + coord_flip()
ggplot(cars, aes(dist, speed)) + geom_point() + geom_smooth() + drk
```

## Coordinate limits

**'Zooming into' a part of the plot is a coordinate transform, not a scale adjustment.**

`coord_cartesian(xlim = c(x1, x2))`

`coord_cartesian(ylim = c(y1, y2))`

`coord_cartesian(xlim = c(x1, x2), ylim = c(y1, y2))`

```{r zoom, fig.show="hold", out.width="50%", message=FALSE, warning=FALSE}
theme_update(title = element_text(size = 20, face = "bold"))

p <- ggplot(mpg, aes(displ, cty)) + geom_point() + geom_smooth()
p + geom_vline(xintercept = 4, linetype = 2) + geom_vline(xintercept = 6, linetype = 2)
p + xlim(c(4, 6)) + drk + ggtitle("xlim")
p + scale_x_continuous(limits = c(4, 6)) + drk + ggtitle("scale limits")
p + coord_cartesian(xlim = c(4, 6)) + ggtitle("coord_cartesian")
theme_set(thm)
```


